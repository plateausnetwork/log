package log

import (
	"fmt"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
)

// Entry represents a generic log entry, that is not (yet) written to the logger.
// You should never manually create an instance of Entry; to get a new instance,
// use the With functions.
type Entry struct {
	inner *logrus.Entry
}

// Debug registers the current entry in the 'Debug' level.
func (e *Entry) Debug(message string) {
	e.inner.Debug(message)
}

// Info registers the current entry in the 'Info' level.
func (e *Entry) Info(message string) {
	e.inner.Info(message)
}

// Warn registers the current entry in the 'Warn' level.
func (e *Entry) Warn(message string) {
	e.inner.Warn(message)
}

// Error registers the current entry in the 'Error' level.
func (e *Entry) Error(err error) {
	e.inner.WithFields(fieldsFromError(err)).Error()
}

// With returns a new log entry, with the supplied fields added to it.
// Supplying the same field more that once (in different With calls) will override,
// not duplicate, the information.
func (e *Entry) With(fields F) *Entry {
	return &Entry{inner: e.inner.WithFields(fields)}
}

// WithError returns a new log entry, with the error information added to
// it. Note that once this method is called, the entry is locked into a
// 'error state', and the only way to finalize the entry is using the
// Error method.
func (e *Entry) WithError(err error) *ErrorEntry {
	return &ErrorEntry{inner: e.inner.WithFields(fieldsFromError(err))}
}

// ErrorEntry is a log entry designed specifically to log errors.
// You should never manually create as instance of ErrorEntry; to get a
// new instance, use the WithError function or the WithError method of an
// existing Entry instance
type ErrorEntry struct {
	inner *logrus.Entry
}

// Error adds a custom message to the current error entry and registers it
// to the logger. Since the actual error object is already registered in the
// current entry, this method expects a string to act as a complementary or
// contextual error information.
// If the message is not supplied, the existing error message is used.
func (e *ErrorEntry) Error(message string) {
	e.inner.Error(message)
}

// With returns a new log entry, with the supplied fields added to it. Note
// that the entry is kept locked in its 'error state'.
func (e *ErrorEntry) With(fields F) *ErrorEntry {
	return &ErrorEntry{inner: e.inner.WithFields(fields)}
}

// stackTracer is a private interface to allow direct access to the
// stack trace generated by pkg/errors.
//
// This is done simply to enable our logs to 'drop' the top 'N'
// frames of the stack, to avoid printing the logging routines
// themselves in the final stack
type stackTracer interface {
	StackTrace() errors.StackTrace
}

func collectStack(dropFrames int, err error) string {
	var stack errors.StackTrace

	if e, ok := err.(stackTracer); ok {
		stack = e.StackTrace()
		dropFrames = 0 // the stack is already present, don't drop anything
	} else {
		e, _ := errors.WithStack(err).(stackTracer)
		stack = e.StackTrace()
		dropFrames++ // drop this frame too
	}

	size := len(stack)

	if size >= dropFrames {
		return fmt.Sprintf("%+v", stack[dropFrames:])
	}

	return ""
}

func fieldsFromError(err error) F {
	stack := collectStack(2, err)
	return F{
		"stack": stack,
		"error": err,
	}
}
